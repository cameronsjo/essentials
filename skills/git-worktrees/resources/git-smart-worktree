#!/usr/bin/env bash
#
# git-smart-worktree - Worktree management with type-based organization
#
# Usage:
#   git-smart-worktree create <type> <slug>   Create worktree (feat, bug, pr, exp, hot, rel)
#   git-smart-worktree list                   List all worktrees with status
#   git-smart-worktree remove <path>          Remove worktree and optionally branch
#   git-smart-worktree setup                  Install deps in current worktree
#
# Examples:
#   git-smart-worktree create feat auth-system
#   git-smart-worktree create pr 123
#   git-smart-worktree list
#   git-smart-worktree remove feat/auth-system
#   git-smart-worktree setup

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Valid worktree types
VALID_TYPES=("feat" "bug" "pr" "exp" "hot" "rel")

usage() {
    cat << 'EOF'
git-smart-worktree - Worktree management with type-based organization

Usage:
  git-smart-worktree create <type> <slug>   Create worktree
  git-smart-worktree list                   List all worktrees
  git-smart-worktree remove <path>          Remove worktree
  git-smart-worktree setup                  Install deps in current worktree

Types:
  feat   Feature development
  bug    Bug fixes
  pr     PR review (detached)
  exp    Experiments
  hot    Hotfixes
  rel    Release branches

Examples:
  git-smart-worktree create feat auth-system
  git-smart-worktree create pr 123
  git-smart-worktree list
  git-smart-worktree remove feat/auth-system
EOF
}

# Find repo root (bare repo or standard)
find_repo_root() {
    local dir
    dir=$(pwd)

    while [[ "$dir" != "/" ]]; do
        # Check for bare repo (ends in .git)
        if [[ -d "$dir" && "$dir" == *.git ]]; then
            echo "$dir"
            return 0
        fi
        # Check for .git directory or file
        if [[ -e "$dir/.git" ]]; then
            echo "$dir"
            return 0
        fi
        dir=$(dirname "$dir")
    done

    return 1
}

# Get default branch name
get_default_branch() {
    local repo_root="$1"
    git -C "$repo_root" symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@' || echo "main"
}

# Check if type is valid
is_valid_type() {
    local type="$1"
    for valid in "${VALID_TYPES[@]}"; do
        [[ "$type" == "$valid" ]] && return 0
    done
    return 1
}

# Detect GitHub host for gh CLI
detect_gh_host() {
    local remote_url
    remote_url=$(git remote get-url origin 2>/dev/null || echo "")

    if [[ "$remote_url" == *"github.com"* ]]; then
        echo "github.com"
    else
        # Extract host from URL (supports enterprise GitHub instances)
        echo "$remote_url" | sed -E 's|.*[@/]([^:/]+)[:/].*|\1|'
    fi
}

# Create worktree
cmd_create() {
    local type="${1:-}"
    local slug="${2:-}"

    if [[ -z "$type" || -z "$slug" ]]; then
        echo -e "${RED}Error: Missing arguments${NC}"
        echo "Usage: git-smart-worktree create <type> <slug>"
        exit 1
    fi

    if ! is_valid_type "$type"; then
        echo -e "${RED}Error: Invalid type '$type'${NC}"
        echo "Valid types: ${VALID_TYPES[*]}"
        exit 1
    fi

    local repo_root
    if ! repo_root=$(find_repo_root); then
        echo -e "${RED}Error: Not in a git repository${NC}"
        exit 1
    fi

    echo -e "${BLUE}→ Detecting repo structure...${NC}"
    echo -e "${BLUE}→ Repo: ${repo_root}${NC}"

    # Fetch latest
    echo -e "${BLUE}→ Fetching latest from origin...${NC}"
    git -C "$repo_root" fetch --all --prune --quiet

    local worktree_path="${repo_root}/${type}/${slug}"
    local branch_name="${type}/${slug}"

    # Special handling for PR type
    if [[ "$type" == "pr" ]]; then
        local pr_number="$slug"
        local gh_host
        gh_host=$(detect_gh_host)

        echo -e "${BLUE}→ Fetching PR #${pr_number} via gh CLI...${NC}"

        local pr_info
        if [[ "$gh_host" != "github.com" ]]; then
            pr_info=$(GH_HOST="$gh_host" gh pr view "$pr_number" --json headRefName,title,author 2>/dev/null) || {
                echo -e "${RED}Error: Could not fetch PR #${pr_number}${NC}"
                echo "Make sure gh CLI is authenticated: GH_HOST=$gh_host gh auth login"
                exit 1
            }
        else
            pr_info=$(gh pr view "$pr_number" --json headRefName,title,author 2>/dev/null) || {
                echo -e "${RED}Error: Could not fetch PR #${pr_number}${NC}"
                exit 1
            }
        fi

        local pr_branch pr_title pr_author
        pr_branch=$(echo "$pr_info" | jq -r '.headRefName')
        pr_title=$(echo "$pr_info" | jq -r '.title')
        pr_author=$(echo "$pr_info" | jq -r '.author.login')

        echo -e "${BLUE}→ PR: \"${pr_title}\" by @${pr_author}${NC}"
        echo -e "${BLUE}→ Branch: ${pr_branch}${NC}"

        # Fetch the PR branch
        git -C "$repo_root" fetch origin "$pr_branch" --quiet

        # Create directory for type if needed
        mkdir -p "${repo_root}/${type}"

        # Create detached worktree
        echo -e "${BLUE}→ Creating detached worktree at ${type}/${slug}/${NC}"
        git -C "$repo_root" worktree add --detach "$worktree_path" "origin/${pr_branch}"

        echo ""
        echo -e "${GREEN}✓ Worktree ready at ${worktree_path}${NC}"
        echo -e "  Branch: ${pr_branch} (detached)"
        echo ""
        echo -e "${YELLOW}Tip: This is read-only review mode. To push changes, check out the branch normally.${NC}"
    else
        # Regular worktree (feat, bug, exp, hot, rel)
        local default_branch
        default_branch=$(get_default_branch "$repo_root")

        echo -e "${BLUE}→ Creating branch: ${branch_name} (from origin/${default_branch})${NC}"

        # Create directory for type if needed
        mkdir -p "${repo_root}/${type}"

        # Create branch and worktree
        echo -e "${BLUE}→ Creating worktree at ${type}/${slug}/${NC}"
        git -C "$repo_root" worktree add -b "$branch_name" "$worktree_path" "origin/${default_branch}"

        echo ""
        echo -e "${GREEN}✓ Worktree ready at ${worktree_path}${NC}"
        echo ""
        echo "Next: cd there and start coding, or run 'git-smart-worktree setup' to install deps."
    fi
}

# List worktrees
cmd_list() {
    local repo_root
    if ! repo_root=$(find_repo_root); then
        echo -e "${RED}Error: Not in a git repository${NC}"
        exit 1
    fi

    local repo_name
    repo_name=$(basename "$repo_root")

    echo "Worktrees in ${repo_name}:"
    echo ""

    local stale_found=false

    while IFS= read -r line; do
        [[ -z "$line" ]] && continue

        local path branch commit
        path=$(echo "$line" | awk '{print $1}')
        commit=$(echo "$line" | awk '{print $2}')
        branch=$(echo "$line" | awk '{print $3}' | tr -d '[]')

        # Get relative path from repo root
        local rel_path
        rel_path="${path#$repo_root/}"
        [[ "$rel_path" == "$path" ]] && rel_path="."

        # Check worktree status
        local status_icon status_text
        if [[ "$branch" == "detached" ]] || [[ -z "$branch" ]]; then
            status_icon="◇"
            status_text="detached @ ${commit:0:7}"
        else
            local changes
            changes=$(git -C "$path" status --porcelain 2>/dev/null | wc -l | tr -d ' ')
            if [[ "$changes" -gt 0 ]]; then
                status_icon="${YELLOW}●${NC}"
                status_text="${branch} (${changes} uncommitted)"
            else
                status_icon="${GREEN}✓${NC}"
                status_text="${branch} (clean)"
            fi

            # Check if branch still exists on remote
            if ! git -C "$repo_root" rev-parse "refs/remotes/origin/${branch}" &>/dev/null; then
                if [[ "$branch" != "main" && "$branch" != "master" ]]; then
                    status_icon="${YELLOW}⚠${NC}"
                    status_text="${branch} — branch may be merged/deleted"
                    stale_found=true
                fi
            fi
        fi

        printf "  %-30s %b %s\n" "${rel_path}/" "$status_icon" "$status_text"

    done < <(git -C "$repo_root" worktree list)

    if $stale_found; then
        echo ""
        echo -e "${YELLOW}Tip: Remove stale worktrees with: git-smart-worktree remove <path>${NC}"
    fi
}

# Remove worktree
cmd_remove() {
    local path="${1:-}"

    if [[ -z "$path" ]]; then
        echo -e "${RED}Error: Missing path argument${NC}"
        echo "Usage: git-smart-worktree remove <path>"
        exit 1
    fi

    local repo_root
    if ! repo_root=$(find_repo_root); then
        echo -e "${RED}Error: Not in a git repository${NC}"
        exit 1
    fi

    local full_path="${repo_root}/${path}"

    if [[ ! -d "$full_path" ]]; then
        echo -e "${RED}Error: Worktree not found: ${path}${NC}"
        exit 1
    fi

    # Check for uncommitted changes
    echo -e "${BLUE}→ Checking for uncommitted changes...${NC}"
    local changes
    changes=$(git -C "$full_path" status --porcelain 2>/dev/null | wc -l | tr -d ' ')

    if [[ "$changes" -gt 0 ]]; then
        echo -e "${YELLOW}Warning: Worktree has ${changes} uncommitted changes${NC}"
        read -p "Continue anyway? (y/n) " -n 1 -r
        echo
        [[ ! $REPLY =~ ^[Yy]$ ]] && exit 1
    else
        echo -e "${BLUE}→ Worktree is clean${NC}"
    fi

    # Get branch name before removal
    local branch
    branch=$(git -C "$full_path" branch --show-current 2>/dev/null || echo "")

    # Remove worktree
    echo -e "${BLUE}→ Removing worktree...${NC}"
    git -C "$repo_root" worktree remove "$full_path"

    # Prune
    echo -e "${BLUE}→ Pruning stale references...${NC}"
    git -C "$repo_root" worktree prune

    echo ""
    echo -e "${GREEN}✓ Removed ${path}/${NC}"

    # Offer to delete branch
    if [[ -n "$branch" && "$branch" != "main" && "$branch" != "master" ]]; then
        echo -e "  Branch ${branch} still exists."
        read -p "  Delete branch too? (y/n) " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            git -C "$repo_root" branch -d "$branch" 2>/dev/null || \
                git -C "$repo_root" branch -D "$branch"
            echo -e "${GREEN}✓ Deleted branch ${branch}${NC}"
        fi
    fi
}

# Setup current worktree
cmd_setup() {
    echo -e "${BLUE}→ Detecting project type...${NC}"

    local found=false

    # Node.js
    if [[ -f "package.json" ]]; then
        found=true
        if command -v pnpm &>/dev/null; then
            echo -e "${BLUE}→ Found: package.json (Node.js)${NC}"
            echo -e "${BLUE}→ Installing dependencies with pnpm...${NC}"
            pnpm install
        elif command -v yarn &>/dev/null; then
            echo -e "${BLUE}→ Found: package.json (Node.js)${NC}"
            echo -e "${BLUE}→ Installing dependencies with yarn...${NC}"
            yarn install
        else
            echo -e "${BLUE}→ Found: package.json (Node.js)${NC}"
            echo -e "${BLUE}→ Installing dependencies with npm...${NC}"
            npm install
        fi
        echo -e "${GREEN}✓ Dependencies installed${NC}"
    fi

    # Python (pyproject.toml)
    if [[ -f "pyproject.toml" ]]; then
        found=true
        echo -e "${BLUE}→ Found: pyproject.toml (Python)${NC}"
        if command -v uv &>/dev/null; then
            echo -e "${BLUE}→ Installing dependencies with uv...${NC}"
            uv sync
        elif command -v poetry &>/dev/null; then
            echo -e "${BLUE}→ Installing dependencies with poetry...${NC}"
            poetry install
        else
            echo -e "${YELLOW}Warning: Neither uv nor poetry found${NC}"
        fi
        echo -e "${GREEN}✓ Dependencies installed${NC}"
    fi

    # Python (requirements.txt)
    if [[ -f "requirements.txt" && ! -f "pyproject.toml" ]]; then
        found=true
        echo -e "${BLUE}→ Found: requirements.txt (Python)${NC}"
        if command -v uv &>/dev/null; then
            echo -e "${BLUE}→ Installing dependencies with uv...${NC}"
            uv pip install -r requirements.txt
        else
            echo -e "${BLUE}→ Installing dependencies with pip...${NC}"
            pip install -r requirements.txt
        fi
        echo -e "${GREEN}✓ Dependencies installed${NC}"
    fi

    # Go
    if [[ -f "go.mod" ]]; then
        found=true
        echo -e "${BLUE}→ Found: go.mod (Go)${NC}"
        echo -e "${BLUE}→ Downloading modules...${NC}"
        go mod download
        echo -e "${GREEN}✓ Modules downloaded${NC}"
    fi

    # Rust
    if [[ -f "Cargo.toml" ]]; then
        found=true
        echo -e "${BLUE}→ Found: Cargo.toml (Rust)${NC}"
        echo -e "${YELLOW}→ Skipping cargo build (run manually if needed)${NC}"
    fi

    # Symlink .env from main if exists
    local repo_root
    repo_root=$(find_repo_root) || true

    if [[ -n "$repo_root" && -f "${repo_root}/main/.env" && ! -f ".env" ]]; then
        echo ""
        echo -e "${BLUE}→ Found .env in main/ worktree${NC}"
        echo -e "${BLUE}→ Creating symlink...${NC}"
        ln -s "${repo_root}/main/.env" .env
        echo -e "${GREEN}✓ Symlinked .env${NC}"
    fi

    # Symlink .envrc from main if exists
    if [[ -n "$repo_root" && -f "${repo_root}/main/.envrc" && ! -f ".envrc" ]]; then
        echo -e "${BLUE}→ Found .envrc in main/ worktree${NC}"
        echo -e "${BLUE}→ Creating symlink...${NC}"
        ln -s "${repo_root}/main/.envrc" .envrc
        if command -v direnv &>/dev/null; then
            direnv allow
        fi
        echo -e "${GREEN}✓ Symlinked .envrc${NC}"
    fi

    if ! $found; then
        echo -e "${YELLOW}No recognized project files found${NC}"
    else
        echo ""
        echo -e "${GREEN}✓ Ready for development${NC}"
    fi
}

# Main
main() {
    local cmd="${1:-}"

    case "$cmd" in
        create)
            shift
            cmd_create "$@"
            ;;
        list|ls)
            cmd_list
            ;;
        remove|rm)
            shift
            cmd_remove "$@"
            ;;
        setup)
            cmd_setup
            ;;
        -h|--help|help|"")
            usage
            ;;
        *)
            echo -e "${RED}Error: Unknown command '$cmd'${NC}"
            usage
            exit 1
            ;;
    esac
}

main "$@"
