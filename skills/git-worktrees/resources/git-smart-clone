#!/usr/bin/env python3
"""
Smart git clone with auto-organization and worktree setup.
Organizes repos into ~/Projects/{host}/{org}/{repo} structure.
"""

import argparse
import os
import re
import subprocess
import sys
from pathlib import Path
from urllib.parse import urlparse


class Colors:
    """ANSI color codes for terminal output."""
    GREEN = '\033[0;32m'
    BLUE = '\033[0;34m'
    YELLOW = '\033[1;33m'
    RED = '\033[0;31m'
    BOLD = '\033[1m'
    NC = '\033[0m'  # No Color


def parse_git_url(url: str) -> tuple[str, str, str]:
    """
    Parse a git URL and extract host, org, and repo name.

    Returns:
        (host, org, repo) tuple
    """
    # Remove .git suffix if present
    url = url.rstrip('/').removesuffix('.git')

    # Try SSH format: git@github.com:user/repo
    ssh_match = re.match(r'^git@([^:]+):([^/]+)/(.+)$', url)
    if ssh_match:
        return ssh_match.group(1), ssh_match.group(2), ssh_match.group(3)

    # Try SSH alternate: ssh://git@github.com/user/repo
    ssh_alt_match = re.match(r'^ssh://git@([^/]+)/([^/]+)/(.+)$', url)
    if ssh_alt_match:
        return ssh_alt_match.group(1), ssh_alt_match.group(2), ssh_alt_match.group(3)

    # Try standard URLs (https, http, git)
    try:
        parsed = urlparse(url)
        if parsed.netloc and parsed.path:
            path_parts = parsed.path.strip('/').split('/')
            if len(path_parts) >= 2:
                host = parsed.netloc
                org = path_parts[0]
                repo = '/'.join(path_parts[1:])
                return host, org, repo
    except Exception:
        pass

    # Unknown format - use public
    repo_name = Path(url).name.removesuffix('.git')
    return 'public', '', repo_name


def convert_to_ssh(url: str) -> str:
    """Convert HTTPS URL to SSH format."""
    https_match = re.match(r'^https://([^/]+)/(.+)$', url)
    if https_match:
        host = https_match.group(1)
        path = https_match.group(2)
        return f'git@{host}:{path}'
    return url


def run_command(cmd: list[str], cwd: str = None, capture: bool = False) -> str:
    """Run a shell command."""
    try:
        if capture:
            result = subprocess.run(
                cmd,
                cwd=cwd,
                capture_output=True,
                text=True,
                check=True
            )
            return result.stdout.strip()
        else:
            subprocess.run(cmd, cwd=cwd, check=True)
            return ""
    except subprocess.CalledProcessError as e:
        print(f"{Colors.RED}Error running command: {' '.join(cmd)}{Colors.NC}")
        if e.stderr:
            print(f"{Colors.RED}{e.stderr}{Colors.NC}")
        sys.exit(1)


def clone_with_worktree(url: str, target_dir: Path, repo_name: str, git_opts: list[str], verbose: bool):
    """Clone repository with worktree setup."""
    repo_dir = target_dir / f"{repo_name}.git"

    if repo_dir.exists():
        print(f"{Colors.RED}Error: Directory already exists: {repo_dir}{Colors.NC}")
        sys.exit(1)

    print(f"{Colors.YELLOW}Using worktree setup (bare repo + worktree){Colors.NC}\n")

    # Clone as bare repository
    print("1. Creating bare repository...")
    run_command(['git', 'clone', '--bare'] + git_opts + [url, str(repo_dir)])

    # Detect default branch
    print("\n2. Detecting default branch...")
    try:
        default_branch = run_command(
            ['git', 'symbolic-ref', 'refs/remotes/origin/HEAD'],
            cwd=str(repo_dir),
            capture=True
        )
        default_branch = default_branch.replace('refs/remotes/origin/', '')
    except:
        default_branch = 'main'

    print(f"   {Colors.GREEN}âœ“{Colors.NC} Default branch: {Colors.BLUE}{default_branch}{Colors.NC}")

    # Create worktree
    print(f"\n3. Creating worktree for '{default_branch}'...")
    run_command(
        ['git', 'worktree', 'add', default_branch, default_branch],
        cwd=str(repo_dir)
    )

    work_dir = repo_dir / default_branch

    print(f"\n{Colors.GREEN}âœ… Repository cloned with worktree setup!{Colors.NC}\n")
    print(f"{Colors.BLUE}Structure:{Colors.NC}")
    print(f"  {target_dir}/")
    print(f"  â””â”€â”€ {repo_name}.git/              {Colors.YELLOW}# Bare repo (git metadata){Colors.NC}")
    print(f"      â””â”€â”€ {default_branch}/         {Colors.YELLOW}# Worktree for {default_branch}{Colors.NC}\n")
    print(f"{Colors.BLUE}Create more worktrees:{Colors.NC}")
    print(f"  cd {repo_dir}")
    print(f"  git worktree add feature/my-feature\n")

    return work_dir


def clone_simple(url: str, target_dir: Path, repo_name: str, git_opts: list[str]):
    """Clone repository with standard git clone."""
    repo_dir = target_dir / repo_name

    if repo_dir.exists():
        print(f"{Colors.RED}Error: Directory already exists: {repo_dir}{Colors.NC}")
        sys.exit(1)

    print(f"{Colors.YELLOW}Using simple clone{Colors.NC}\n")

    run_command(['git', 'clone'] + git_opts + [url, str(repo_dir)])

    print(f"\n{Colors.GREEN}âœ… Repository cloned!{Colors.NC}\n")
    print(f"{Colors.BLUE}Location:{Colors.NC}")
    print(f"  {repo_dir}\n")

    return repo_dir


def main():
    parser = argparse.ArgumentParser(
        description='Smart git clone with auto-organization and worktree setup',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # GitHub repo (creates ~/Projects/github.com/user/repo.git/)
  git-smart-clone https://github.com/anthropics/claude-code.git

  # With SSH conversion
  git-smart-clone --ssh https://github.com/user/repo.git

  # Simple clone (no worktree)
  git-smart-clone --simple https://github.com/user/repo.git

Structure:
  ~/Projects/
  â”œâ”€â”€ github.com/
  â”‚   â”œâ”€â”€ anthropics/
  â”‚   â”‚   â””â”€â”€ claude-code.git/
  â”‚   â”‚       â””â”€â”€ main/            # worktree
  â”‚   â””â”€â”€ user/
  â”‚       â””â”€â”€ repo.git/
  â””â”€â”€ public/
      â””â”€â”€ unknown-repo.git/
        """
    )

    parser.add_argument('url', help='Repository URL to clone')
    parser.add_argument('--simple', action='store_true',
                       help='Use normal clone (no worktree setup)')
    parser.add_argument('--ssh', action='store_true',
                       help='Convert HTTPS URLs to SSH')
    parser.add_argument('-v', '--verbose', action='store_true',
                       help='Verbose output')
    parser.add_argument('git_opts', nargs='*',
                       help='Additional git clone options')

    args = parser.parse_args()

    # Configuration
    projects_dir = Path.home() / 'Projects'
    repo_url = args.url

    # Convert to SSH if requested
    if args.ssh:
        original_url = repo_url
        repo_url = convert_to_ssh(repo_url)
        if args.verbose:
            print(f"{Colors.BLUE}Converted to SSH:{Colors.NC} {repo_url}")

    # Parse URL
    host, org, repo = parse_git_url(repo_url)

    if args.verbose:
        print(f"{Colors.BLUE}Parsed URL:{Colors.NC} host={host}, org={org}, repo={repo}")

    # Determine target directory
    if org:
        target_dir = projects_dir / host / org
    else:
        target_dir = projects_dir / host

    target_dir.mkdir(parents=True, exist_ok=True)

    if args.verbose:
        print(f"{Colors.BLUE}Target directory:{Colors.NC} {target_dir}")

    # Clone!
    print(f"{Colors.GREEN}ðŸ“¦ Cloning repository...{Colors.NC}\n")
    print(f"  {Colors.BLUE}Source:{Colors.NC} {repo_url}")
    print(f"  {Colors.BLUE}Target:{Colors.NC} {target_dir}\n")

    if args.simple:
        work_dir = clone_simple(repo_url, target_dir, repo, args.git_opts)
    else:
        work_dir = clone_with_worktree(repo_url, target_dir, repo, args.git_opts, args.verbose)

    # Print navigation command
    print(f"{Colors.GREEN}To navigate:{Colors.NC}")
    print(f"  cd {work_dir}")


if __name__ == '__main__':
    main()
